/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : DMA1.c
**     Project     : ProcessorExpert
**     Processor   : MK60FN1M0VLQ15
**     Component   : DMA_LDD
**     Version     : Component 01.065, Driver 01.07, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2019-08-19, 13:17, # CodeGen: 45
**     Abstract    :
**          This embedded component implements initialization
**          and runtime handling of an on-chip DMA controller.
**     Settings    :
**          Component name                                 : DMA1
**          Device                                         : DMA
**          Settings                                       : 
**            Minor loop mapping                           : Disabled
**            Continuous mode                              : Disabled
**            Halt on error                                : Disabled
**            Debug                                        : Enabled
**          Channel arbitration type                       : Round robin
**          DMA channels                                   : 1
**            Settings of DMA channel                      : DMA_Channel0
**              Channel                                    : DMA_Channel0
**              Channel arbitration type                   : Round robin
**              Interrupt service                          : Enabled
**                Transfer complete interrupt              : INT_DMA0_DMA16
**                Transfer complete interrupt priority     : medium priority
**                Error interrupt                          : INT_DMA_Error
**                Error interrupt priority                 : medium priority
**          Initialization                                 : 
**            Enabled in init. code                        : yes
**            Auto initialization                          : no
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component disabled
**            Clock configuration 2                        : This component disabled
**            Clock configuration 3                        : This component disabled
**            Clock configuration 4                        : This component disabled
**            Clock configuration 5                        : This component disabled
**            Clock configuration 6                        : This component disabled
**            Clock configuration 7                        : This component disabled
**     Contents    :
**         Init                         - LDD_TDeviceData* DMA1_Init(LDD_TUserData *UserDataPtr);
**         Enable                       - LDD_TError DMA1_Enable(LDD_TDeviceData *DeviceDataPtr);
**         Disable                      - LDD_TError DMA1_Disable(LDD_TDeviceData *DeviceDataPtr);
**         AllocateChannel              - LDD_TError DMA1_AllocateChannel(LDD_TDeviceData *DeviceDataPtr,...
**         EnableChannel                - LDD_TError DMA1_EnableChannel(LDD_TDeviceData *DeviceDataPtr,...
**         StartChannelTransfer         - LDD_TError DMA1_StartChannelTransfer(LDD_TDeviceData *DeviceDataPtr,...
**         CancelChannelTransfer        - LDD_TError DMA1_CancelChannelTransfer(LDD_TDeviceData *DeviceDataPtr,...
**         SetChannelSourceAddress      - LDD_TError DMA1_SetChannelSourceAddress(LDD_TDeviceData *DeviceDataPtr,...
**         SetChannelDestinationAddress - LDD_TError DMA1_SetChannelDestinationAddress(LDD_TDeviceData *DeviceDataPtr,...
**         SetChannelByteCount          - LDD_TError DMA1_SetChannelByteCount(LDD_TDeviceData *DeviceDataPtr,...
**
**     Copyright : 1997 - 2013 Freescale Semiconductor, Inc. All Rights Reserved.
**     SOURCE DISTRIBUTION PERMISSIBLE as directed in End User License Agreement.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/
/*!
** @file DMA1.c
** @version 01.07
** @brief
**          This embedded component implements initialization
**          and runtime handling of an on-chip DMA controller.
*/         
/*!
**  @addtogroup DMA1_module DMA1 module documentation
**  @{
*/         

/* MODULE DMA1. */

#include "DAC.h"
#include "DMA1.h"

/* {Default RTOS Adapter} No RTOS includes */

/* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
static DMA1_TDeviceData DeviceDataPtr__DEFAULT_RTOS_ALLOC;
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static DMA1_TDeviceData * INT_DMA_Error__DEFAULT_RTOS_ISRPARAM;
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static DMA1_TDeviceData * INT_DMA0_DMA16__DEFAULT_RTOS_ISRPARAM;
/* Channel numbers initialization table */
static const LDD_DMA_TChannelNumber DMA1_ChannelNumbers[DMA1_CONFIGURED_CHANNELS_NUMBER] = {
  0x00U
};
/* Channel masks initialization table */
static const LDD_DMA_TChannelMask DMA1_ChannelMasks[DMA1_CONFIGURED_CHANNELS_NUMBER] = {
  LDD_DMA_CHANNEL_0_MASK
};
/* Channel interrupts enable initialization table */
static const bool DMA1_ChannelInterrupts[DMA1_CONFIGURED_CHANNELS_NUMBER] = {
  TRUE
};

/* Internal method prototypes */
static bool GetRecord(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, DMA1_TDescriptorRecordPtr *DescriptorRecordAddressPtr);
static bool GetChannelNumber(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TChannelNumber *ChannelNumberPtr);
static bool VerifyDescriptor(LDD_DMA_TTransferDescriptor *DescriptorPtr);

/*
** ===================================================================
**     Method      :  DMA1_Init (component DMA_LDD)
*/
/*!
**     @brief
**         Initializes the device according to design-time
**         configuration properties. Allocates memory for the device
**         data structure. 
**         If the <Enable in init. code> is set to "yes" then the
**         device is also enabled (see the description of the Enable
**         method).
**         This method can be called only once. Before the second call
**         of Init the Deinit method must be called first.
**     @param
**         UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter.
**     @return
**                         - Pointer to the device data structure. 
*/
/* ===================================================================*/
LDD_TDeviceData* DMA1_Init(LDD_TUserData *UserDataPtr)
{
  uint8_t i;
  DMA1_TDeviceData *DeviceDataPtr;     /* LDD device structure */
  DMA1_TDescriptorRecord *DescriptorRecordPtr; /* Auxiliary local pointer to internal descriptor records. */

  /* Allocate HAL device structure */
  /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DeviceDataPtr = &DeviceDataPtr__DEFAULT_RTOS_ALLOC;
  DeviceDataPtr->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
  /* Enable device clock gate */
  /* SIM_SCGC7: DMA=1 */
  SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;                                   
  /* SIM_SCGC6: DMAMUX0=1 */
  SIM_SCGC6 |= SIM_SCGC6_DMAMUX0_MASK;                                   
  /* Error interrupt vector allocation */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_DMA_Error__DEFAULT_RTOS_ISRPARAM = DeviceDataPtr;
  /* Error interrupt vector priority setting */
  /* NVICIP16: PRI16=0x80 */
  NVICIP16 = NVIC_IP_PRI16(0x80);                                   
  /* NVICISER0: SETENA|=0x00010000 */
  NVICISER0 |= NVIC_ISER_SETENA(0x00010000);                                   
  /* Transfer compete interrupt vector(s) allocation */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_DMA0_DMA16__DEFAULT_RTOS_ISRPARAM = DeviceDataPtr;
  /* Transfer compete interrupt vector(s) priority setting */
  /* NVICIP0: PRI0=0x80 */
  NVICIP0 = NVIC_IP_PRI0(0x80);                                   
  /* NVICISER0: SETENA|=1 */
  NVICISER0 |= NVIC_ISER_SETENA(0x01);                                   
  DMA_PDD_ClearErrorInterruptEnable(DMA_BASE_PTR, DMA_PDD_ALL_CHANNELS, 0x00U); /* Disable all interrupts */
  DMA_PDD_ClearRequestEnable(DMA_BASE_PTR, DMA_PDD_ALL_CHANNELS, 0x00U); /* Disable all HW requests */
  DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, DMA_PDD_ALL_CHANNELS, 0x00U); /* Clear request interrupt flags */
  DMA_PDD_ClearErrorFlags(DMA_BASE_PTR, DMA_PDD_ALL_CHANNELS, 0x00U); /* Clear error interrupt flags */
  /* Initialization of channels record field. */
  for(i = 0U; i < DMA1_DMA_CHANNELS_NUMBER; i++) {
    DeviceDataPtr->ChannelRecord[i] = NULL; /* Clear pointer to descriptor record of all channels. */
  }
  /* Initialization of channel and descriptor record fields. */
  for(i = 0U; i < DMA1_CONFIGURED_CHANNELS_NUMBER; i++) {
    DescriptorRecordPtr = &(DeviceDataPtr->DescriptorRecord[i]); /* Store local pointer to descriptor record. */
    DescriptorRecordPtr->ChannelNumber = DMA1_ChannelNumbers[i]; /* Store associated channel number. */
    DescriptorRecordPtr->DescriptorPtr = NULL; /* Set channel as free. */
    DescriptorRecordPtr->Interrupts = DMA1_ChannelInterrupts[i]; /* Store associated channel interrupts enabled/disabled status. */
    DescriptorRecordPtr->Initialized = FALSE; /* Set channel as not initialized. */
    DescriptorRecordPtr->Enabled = FALSE; /* Set channel as disabled. */
    DeviceDataPtr->ChannelRecord[DMA1_ChannelNumbers[i]] = DescriptorRecordPtr; /* Store pointers to descriptor records of fixed channels. */
  }
  /* DMA_CR: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,CX=0,ECX=0,??=0,??=0,??=0,??=0,GRP1PRI=0,GRP0PRI=0,EMLM=0,CLM=0,HALT=0,HOE=0,ERGA=1,ERCA=1,EDBG=0,??=0 */
  DMA_CR = DMA_CR_GRP1PRI(0x00) |
           DMA_CR_GRP0PRI(0x00) |
           DMA_CR_ERGA_MASK |
           DMA_CR_ERCA_MASK;       
  DeviceDataPtr->EnUser = TRUE;        /* Set the flag "device enabled by user" */
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_DMA1_ID,DeviceDataPtr);
  return ((LDD_TDeviceData *)DeviceDataPtr); /* Return pointer to the data structure */
}

/*
** ===================================================================
**     Method      :  DMA1_Enable (component DMA_LDD)
*/
/*!
**     @brief
**         Enables DMA device.
**         This method is intended to be used together with Disable
**         method to temporary switch On/Off the device after the
**         device is initialized.
**         This method is required if the <Enable in init. code>
**         property is set to "no" value.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
*/
/* ===================================================================*/
LDD_TError DMA1_Enable(LDD_TDeviceData *DeviceDataPtr)
{
  ((DMA1_TDeviceData *)DeviceDataPtr)->EnUser = TRUE;
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_Disable (component DMA_LDD)
*/
/*!
**     @brief
**         Disables the DMA device. When the device is disabled, some
**         component methods should not be called. If so, error
**         ERR_DISABLED is reported.
**         This method is intended to be used together with Enable
**         method to temporary switch On/Off the device after the
**         device is initialized.
**         This method is not required. The Deinit method can be used
**         to switch off and uninstall the device.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
*/
/* ===================================================================*/
LDD_TError DMA1_Disable(LDD_TDeviceData *DeviceDataPtr)
{
  ((DMA1_TDeviceData *)DeviceDataPtr)->EnUser = FALSE;
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_AllocateChannel (component DMA_LDD)
*/
/*!
**     @brief
**         The method allocates DMA channel for the DMA transfer
**         defined by the transfer descriptor input parameter
**         DescriptorPtr. This method must be called before DMA channel
**         is initialized. Otherwise ERR_NOTAVAIL error code is
**         returned after call of DMA_LDD channel methods.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any possible
**                           channel with desired features to be
**                           allocated.
*/
/* ===================================================================*/
LDD_TError DMA1_AllocateChannel(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  DMA1_TDeviceData *LocalDeviceDataPtr = (DMA1_TDeviceData *)DeviceDataPtr; /* Auxiliary variable - pointer to an internal state structure */
  DMA1_TDescriptorRecord *DescriptorRecordPtr; /* Auxiliary local pointer to internal descriptor records. */
  bool ChannelFound = FALSE;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA1_TDeviceData *)(DeviceDataPtr))->EnUser) { /* Is the device disabled by user? */
    return ERR_DISABLED;               /* No, return ERR_DISABLED. */
  }
  if (!DescriptorPtr->ChannelAutoSelection) { /* Fixed channel wanted? */
    DescriptorRecordPtr = LocalDeviceDataPtr->ChannelRecord[DescriptorPtr->ChannelNumber]; /* Store local pointer to internal descriptor record. */
    if (DescriptorRecordPtr->DescriptorPtr == NULL) { /* Is channel free? */
      /* Allocate channel */
      DescriptorRecordPtr->DescriptorPtr = DescriptorPtr;
      ChannelFound = TRUE;
    }
  }
  if (ChannelFound) {
    return ERR_OK;
  }
  else {
    return ERR_NOTAVAIL;
  }
}

/*
** ===================================================================
**     Method      :  DMA1_EnableChannel (component DMA_LDD)
*/
/*!
**     @brief
**         The method initializes and/or enables the DMA channel
**         allocated for the DMA transfer defined by the transfer
**         descriptor input parameter DescriptorPtr. First call of this
**         method on given DMA channel initializes it and enables HW
**         requests if Peripheral device or Always enabled trigger
**         source is selected in transfer descriptor Trigger source
**         type item. This method can be also used together with
**         Disable method to temporary switch On/Off the DMA channel HW
**         requests. In such case DMA channel registers are not
**         reinitialized again. New initialization of DMA channel can
**         be done via SetChannelDescriptorUpdate method which
**         reinitializes whole channel with new transfer descriptor.
**         After calling of EnableChannel method channel status is set
**         to LDD_DMA_IDLE.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Transfer descriptor data
**                           are inconsistent.
*/
/* ===================================================================*/
LDD_TError DMA1_EnableChannel(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  LDD_DMA_TChannelNumber ChannelNumber;
  DMA1_TDescriptorRecord *DescriptorRecordPtr;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA1_TDeviceData *)(DeviceDataPtr))->EnUser) { /* Is the device disabled by user? */
    return ERR_DISABLED;               /* No, return ERR_DISABLED. */
  }
  /* Check channel allocation for the transfer descriptor and eventually store pointer to associated descriptor record. */
  if (!GetRecord(DeviceDataPtr, DescriptorPtr, &DescriptorRecordPtr)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* Transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (!VerifyDescriptor(DescriptorPtr)) {
    return ERR_PARAM_DATA;
  }
  ChannelNumber = DescriptorRecordPtr->ChannelNumber; /* Save local auxiliary channel number. */
  if (!DescriptorRecordPtr->Initialized) { /* Is channel already initialized? */
    /* If channel is not initialized yet, initialize and enable it */
    DMA_PDD_ClearRequestEnable(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, ChannelNumber); /* Disable channel HW requests. */
    DMA_PDD_ClearChannelActivityFlags(DMA_BASE_PTR, ChannelNumber, DMA_PDD_TRANSFER_DONE_FLAG); /* Clear DMA transfer done status flag. */
    /* Transfer attributes: source transfer size, destination transfer size, source modulo, destination modulo */
    DMA_PDD_SetSourceAddressModulo(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceModuloSize);
    DMA_PDD_SetSourceDataTransferSize(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceTransferSize);
    DMA_PDD_SetDestinationAddressModulo(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationModuloSize);
    DMA_PDD_SetDestinationDataTransferSize(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationTransferSize);
    /* Source address */
    DMA_PDD_SetSourceAddress(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceAddress);
    /* Source address offset */
    DMA_PDD_SetSourceAddressOffset(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceAddressOffset);
    /* Destination address */
    DMA_PDD_SetDestinationAddress(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationAddress);
    /* Destination address offset */
    DMA_PDD_SetDestinationAddressOffset(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationAddressOffset);
    /* Minor loop byte count */
    DMA_PDD_SetByteCount32(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->ByteCount);
    /* Major loop settings */
    DMA_PDD_WriteCurrentMajorLoopCountReg(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->OuterLoopCount); /* Major loop (transfers) count. */
    DMA_PDD_WriteBeginningMajorLoopCountReg(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->OuterLoopCount); /* Major loop (transfers) count. */
    if (DescriptorPtr->InnerLoopChannelLink) { /* Minor loop linking enabled? */
      /* Minor loop linking settings */
      DMA_PDD_SetBeginningMinorLinkChannel(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->InnerLoopLinkedChannel);
      DMA_PDD_EnableBeginningMinorLoopLinking(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
      DMA_PDD_SetCurrentMinorLinkChannel(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->InnerLoopLinkedChannel);
      DMA_PDD_EnableCurrentMinorLoopLinking(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    /* TCD's control and status register */
    DMA_PDD_WriteControlStatusReg(DMA_BASE_PTR, ChannelNumber, 0U); /* Clear control status register. */
    DMA_PDD_SetStallTime(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->BandwidthControl); /* Set stall time during transfer. */
    if (DescriptorPtr->OuterLoopChannelLink) { /* Channel linking after transfer complete enabled? */
      DMA_PDD_SetMajorLinkChannel(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->OuterLoopLinkedChannel); /* Set linked channel number. */
      DMA_PDD_EnableMajorLoopLinking(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable linking. */
    }
    if (DescriptorPtr->DisableAfterRequest) { /* Disable after request? */
      DMA_PDD_EnableRequestAutoDisable(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    /* After transfer complete operation settings */
    if (DescriptorPtr->AfterTransferComplete == LDD_DMA_SCATTER_GATHER) {
      DMA_PDD_EnableScatterGather(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable scatter/gather function. */
      DMA_PDD_SetLastSourceAddressAdjustment(DMA_BASE_PTR, ChannelNumber, 0U); /* Source address adjustment. */
      /* Scatter/gather address (address of next TCD) */
      DMA_PDD_SetLastDestinationAddressAdjustment_ScatterGather(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->ScatterGatherAddress);
    }
    else {
      DMA_PDD_SetLastSourceAddressAdjustment(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceAddressAdjustment); /* Source address adjustment. */
      DMA_PDD_SetLastDestinationAddressAdjustment_ScatterGather(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationAddressAdjustment); /* Destination address adjustment. */
    }
    /* {Default RTOS Adapter} Critical section begin, general PE function is used */
    EnterCritical();
    DescriptorRecordPtr->Initialized = TRUE; /* Mark channel as initialized. */
    DescriptorRecordPtr->Enabled = TRUE; /* Mark channel as enabled. */
    DescriptorPtr->ChannelEnabled = TRUE; /* Mark channel as enabled in transfer descriptor. */
    if (DescriptorPtr->OnError) {      /* Is error event enabled? */
      DMA_PDD_SetErrorInterruptEnable(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, ChannelNumber);
    }
    if (DescriptorPtr->OnComplete) {   /* Is transfer complete event enabled? */
      DMA_PDD_EnableTransferCompleteInterrupt(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    if (DescriptorPtr->OnHalfComplete) { /* Is transfer half complete feature enabled? */
      DMA_PDD_EnableTransferHalfInterrupt(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    /* Set up DMAMUX0 (no channel connected to DMAMUX1 used) */
    DMAMUX_PDD_WriteChannelConfigurationReg(DMAMUX0_BASE_PTR, ChannelNumber, 0U); /* Clear DMA MUX channel source register. */
    if (DescriptorPtr->TriggerType != LDD_DMA_SW_TRIGGER) { /* SW trigger doesn't need MUX channel nor enabled hardware requests. */
      DMAMUX_PDD_SetChannelSource(DMAMUX0_BASE_PTR, ChannelNumber, DescriptorPtr->TriggerSource); /* Set MUX channel source. */
      if (DescriptorPtr->PeriodicTrigger) { /* Periodic trigger needed? */
        DMAMUX_PDD_EnableTrigger(DMAMUX0_BASE_PTR, ChannelNumber, PDD_ENABLE);
      }
      DMAMUX_PDD_EnableChannel(DMAMUX0_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable channel. */
    }
    DMA_PDD_SetRequestEnable(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, ChannelNumber); /* Enable DMA transfer request. */
    /* {Default RTOS Adapter} Critical section end, general PE function is used */
    ExitCritical();
  }
  else {
    /* If channel has already been initialized then enable it only */
    /* {Default RTOS Adapter} Critical section begin, general PE function is used */
    EnterCritical();
    DescriptorRecordPtr->Enabled = TRUE; /* Mark channel as enabled. */
    DescriptorPtr->ChannelEnabled = TRUE; /* Mark channel as enabled in transfer descriptor. */
    if (DescriptorPtr->TriggerType != LDD_DMA_SW_TRIGGER) { /* SW trigger doesn't need enabled hardware requests. */
      DMA_PDD_SetRequestEnable(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, ChannelNumber); /* Enable DMA transfer request. */
    }
    DMA_PDD_ClearChannelActivityFlags(DMA_BASE_PTR, ChannelNumber, DMA_PDD_TRANSFER_DONE_FLAG); /* Clear DMA transfer done status flag. */
    /* {Default RTOS Adapter} Critical section end, general PE function is used */
    ExitCritical();
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_StartChannelTransfer (component DMA_LDD)
*/
/*!
**     @brief
**         The method starts DMA transfer on the allocated DMA channel
**         defined by the transfer descriptor input parameter
**         DescriptorPtr. This methods initiates explicit SW transfer
**         request and can be called after channel is initialized by
**         first calling of EnableChannel method. Explicit SW transfer
**         request is serviced regardless of disabling HW requests
**         after calling of the DisableChannel method.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
*/
/* ===================================================================*/
LDD_TError DMA1_StartChannelTransfer(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  DMA1_TDescriptorRecord *DescriptorRecordPtr;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA1_TDeviceData *)(DeviceDataPtr))->EnUser) { /* Is the device disabled by user? */
    return ERR_DISABLED;               /* No, return ERR_DISABLED. */
  }
  /* Check channel allocation for the transfer descriptor and eventually store pointer to associated descriptor record. */
  if (!GetRecord(DeviceDataPtr, DescriptorPtr, &DescriptorRecordPtr)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  if (!DescriptorRecordPtr->Initialized) {
    return ERR_NOTAVAIL;
  }
  DMA_PDD_StartTransfer(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, DescriptorRecordPtr->ChannelNumber); /* Explicit start of transfer. */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_CancelChannelTransfer (component DMA_LDD)
*/
/*!
**     @brief
**         The method cancels DMA transfer on channel specified by the
**         transfer descriptor input parameter DescriptorPtr. The
**         cancel takes effect after the last write of the current
**         read/write sequence and the channel retires as if the
**         request was serviced normally.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
*/
/* ===================================================================*/
LDD_TError DMA1_CancelChannelTransfer(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  LDD_DMA_TRecordNumber i;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA1_TDeviceData *)(DeviceDataPtr))->EnUser) { /* Is the device disabled by user? */
    return ERR_DISABLED;               /* No, return ERR_DISABLED. */
  }
  /* Try find match between tested descriptor pointer and stored records. */
  for (i = 0U; i < DMA1_CONFIGURED_CHANNELS_NUMBER; i++) {
    if (((DMA1_TDeviceData *)DeviceDataPtr)->DescriptorRecord[i].DescriptorPtr == DescriptorPtr) {
      DMA_PDD_CancelTransfer(DMA_BASE_PTR); /* Cancel transfer. */
      return ERR_OK;
    }
  }
  return ERR_NOTAVAIL;                 /* Transfer descriptor is not associated with any channel. */
}

/*
** ===================================================================
**     Method      :  DMA1_SetChannelSourceAddress (component DMA_LDD)
*/
/*!
**     @brief
**         The method sets an source address for data to be transferred
**         by the DMA channel allocated for the DMA transfer defined by
**         the transfer descriptor parameter DescriptorPtr. This method
**         can be used to update DMA transfer source address when DMA
**         channel is enabled. New source address is stored in transfer
**         descriptor and written to associated DMA channel registers.
**         The new source address can be optionally checked for
**         consistency with rest of the transfer descriptor data.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @param
**         Address         - Address of source data for a DMA
**                           channel allocated for a DMA transfer
**                           descriptor defined by the TCD parameter.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Selected source address
**                           is inconsistent with rest of transfer
**                           descriptor data.
*/
/* ===================================================================*/
LDD_TError DMA1_SetChannelSourceAddress(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TAddress Address)
{
  LDD_DMA_TAddress LocalAddress;
  LDD_DMA_TChannelNumber ChannelNumber;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA1_TDeviceData *)(DeviceDataPtr))->EnUser) { /* Is the device disabled by user? */
    return ERR_DISABLED;               /* No, return ERR_DISABLED. */
  }
  /* Check channel allocation for the transfer descriptor and eventually store associated DMA channel number. */
  if (!GetChannelNumber(DeviceDataPtr, DescriptorPtr, &ChannelNumber)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* New transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  LocalAddress = DescriptorPtr->SourceAddress; /* Save actual address. */
  DescriptorPtr->SourceAddress = Address; /* Store new address in transfer descriptor. */
  if (!VerifyDescriptor(DescriptorPtr)) { /* Test consistency of new transfer descriptor. */
    DescriptorPtr->SourceAddress = LocalAddress; /* If failed, restore previous value. */
    return ERR_PARAM_DATA;
  }
  DMA_PDD_SetSourceAddress(DMA_BASE_PTR, ChannelNumber, Address);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_SetChannelDestinationAddress (component DMA_LDD)
*/
/*!
**     @brief
**         The method sets an destination address for data to be
**         transferred by the DMA channel allocated for the DMA
**         transfer defined by the transfer descriptor parameter
**         DescriptorPtr. This method can be used to update DMA
**         transfer destination address when DMA channel is enabled.
**         New destination address is stored in transfer descriptor and
**         written to associated DMA channel registers. The new
**         destination address can be optionally checked for
**         consistency with rest of the transfer descriptor data.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @param
**         Address         - Address of a destination data to
**                           be transferred to by the DMA channel
**                           allocated for a DMA transfer descriptor
**                           defined by the TCD parameter.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Selected source address
**                           is inconsistent with rest of transfer
**                           descriptor data.
*/
/* ===================================================================*/
LDD_TError DMA1_SetChannelDestinationAddress(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TAddress Address)
{
  LDD_DMA_TAddress LocalAddress;
  LDD_DMA_TChannelNumber ChannelNumber;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA1_TDeviceData *)(DeviceDataPtr))->EnUser) { /* Is the device disabled by user? */
    return ERR_DISABLED;               /* No, return ERR_DISABLED. */
  }
  /* Check channel allocation for the transfer descriptor and eventually store associated DMA channel number. */
  if (!GetChannelNumber(DeviceDataPtr, DescriptorPtr, &ChannelNumber)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* New transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  LocalAddress = DescriptorPtr->DestinationAddress; /* Save actual address. */
  DescriptorPtr->DestinationAddress = Address; /* Store new address in transfer descriptor. */
  if (!VerifyDescriptor(DescriptorPtr)) { /* Test consistency of new transfer descriptor. */
    DescriptorPtr->DestinationAddress = LocalAddress; /* If failed, restore previous value. */
    return ERR_PARAM_DATA;
  }
  DMA_PDD_SetDestinationAddress(DMA_BASE_PTR, ChannelNumber, Address);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_SetChannelByteCount (component DMA_LDD)
*/
/*!
**     @brief
**         The method sets a byte count (size of data) to be
**         transferred by the DMA channel allocated for the DMA
**         transfer defined by the transfer descriptor input parameter
**         DescriptorPtr. This method can be used to update DMA
**         transfer byte count when DMA channel is enabled. New
**         transfer byte count is stored in transfer descriptor and
**         written to associated DMA channel registers. The new
**         transfer byte count can be optionally checked for
**         consistency with rest of the transfer descriptor data. If
**         nested operation is used, the method sets the minor (inner)
**         loop byte count.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @param
**         ByteCount       - Byte count (size of data) to
**                           be transferred by the DMA channel allocated
**                           for a DMA transfer descriptor defined by
**                           the TCD parameter.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Selected byte count is
**                           inconsistent with rest of transfer
**                           descriptor data.
*/
/* ===================================================================*/
LDD_TError DMA1_SetChannelByteCount(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TByteCount ByteCount)
{
  LDD_DMA_TByteCount LocalByteCount;
  LDD_DMA_TChannelNumber ChannelNumber;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA1_TDeviceData *)(DeviceDataPtr))->EnUser) { /* Is the device disabled by user? */
    return ERR_DISABLED;               /* No, return ERR_DISABLED. */
  }
  /* Check channel allocation for the transfer descriptor and eventually store associated DMA channel number. */
  if (!GetChannelNumber(DeviceDataPtr, DescriptorPtr, &ChannelNumber)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* Transferred byte count range test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (ByteCount > DMA1_MAX_BYTE_COUNT) { /* Test if ByteCount is in correct range. */
    return ERR_PARAM_DATA;
  }   
  /* New transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  LocalByteCount = DescriptorPtr->ByteCount; /* Save actual byte count. */
  DescriptorPtr->ByteCount = ByteCount; /* Store new byte count in transfer descriptor. */
  if (!VerifyDescriptor(DescriptorPtr)) { /* Test consistency of new transfer descriptor. */
    DescriptorPtr->ByteCount = LocalByteCount; /* If failed, restore previous value. */
    return ERR_PARAM_DATA;
  }
  DMA_PDD_SetByteCount32(DMA_BASE_PTR, ChannelNumber, ByteCount);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  VerifyDescriptor (component DMA_LDD)
**
**     Description :
**         The method verifies a transfer descriptor of allocated channel 
**         defined by the pointer to its address. Returns TRUE if the 
**         channel's transfer descriptor is correct, FALSE if 
**         inconsistency is detected.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool VerifyDescriptor(LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  /* Store source transfer size byte divider mask */
  LDD_DMA_TTransferSize DividerMask = (LDD_DMA_TTransferSize)(0x01U << DescriptorPtr->SourceTransferSize) - 0x01U;

  /* Is minor loop byte count a multiple of the source transfer size? */
  if ((LDD_DMA_TTransferSize)(DescriptorPtr->ByteCount) & DividerMask) {
    return FALSE;                      /* If no, return. */
  }
  /* Is source address aligned to source transfer size? */
  if ((LDD_DMA_TTransferSize)(DescriptorPtr->SourceAddress) & DividerMask) {
    return FALSE;                      /* If no, return. */
  }
  /* Is source address offset aligned to source transfer size? */
  if ((LDD_DMA_TTransferSize)(DescriptorPtr->SourceAddressOffset) & DividerMask) {
    return FALSE;                      /* If no, return. */
  }
  /* Store destination transfer size byte divider mask */
  DividerMask = (LDD_DMA_TTransferSize)(0x01U << (DescriptorPtr->DestinationTransferSize)) - 0x01U;
  /* Is minor loop byte count a multiple of the destination transfer size? */
  if ((LDD_DMA_TTransferSize)(DescriptorPtr->ByteCount) & DividerMask) {
    return FALSE;                      /* If no, return. */
  }
  /* Is destination address aligned to destination transfer size? */
  if ((LDD_DMA_TTransferSize)(DescriptorPtr->DestinationAddress) & DividerMask) {
    return FALSE;                      /* If no, return. */
  }
  /* Is destination address offset aligned to destination transfer size? */
  if ((LDD_DMA_TTransferSize)(DescriptorPtr->DestinationAddressOffset) & DividerMask) {
    return FALSE;                      /* If no, return. */
  }
  return TRUE;                         /* Channel descriptor verified. */
}

/*
** ===================================================================
**     Method      :  GetChannelNumber (component DMA_LDD)
**
**     Description :
**         The method returns TRUE if some channel is allocated for the 
**         given descriptor, false if it is not. Number of allocated 
**         channel is returned indirectly into the ChannelNumber 
**         parameter.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool GetChannelNumber(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TChannelNumber *ChannelNumber)
{
bool ChannelFound = FALSE;

  if (((DMA1_TDeviceData *)DeviceDataPtr)->ChannelRecord[DescriptorPtr->ChannelNumber]->DescriptorPtr == DescriptorPtr) {
    ChannelFound = TRUE;
    *ChannelNumber = DescriptorPtr->ChannelNumber; /* Save channel number. */
  }
  return ChannelFound;
}

/*
** ===================================================================
**     Method      :  GetRecord (component DMA_LDD)
**
**     Description :
**         The method returns TRUE if some channel is allocated for the 
**         given descriptor, false if it is not. Pointer to the 
**         descriptor record of allocated channel is returned indirectly 
**         into the DescriptorRecordPtr parameter.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool GetRecord(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, DMA1_TDescriptorRecordPtr *DescriptorRecordAddressPtr)
{
  bool RecordFound = FALSE;

  if (((DMA1_TDeviceData *)DeviceDataPtr)->ChannelRecord[DescriptorPtr->ChannelNumber]->DescriptorPtr == DescriptorPtr) {
    RecordFound = TRUE;
    *DescriptorRecordAddressPtr = ((DMA1_TDeviceData *)DeviceDataPtr)->ChannelRecord[DescriptorPtr->ChannelNumber]; /* Save descriptors record address. */
  }
  return RecordFound;
}

/*
** ===================================================================
**     Method      :  ErrorInterrupt (component DMA_LDD)
**
**     Description :
**         Error interrupt service routine.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(DMA1_ErrorInterrupt)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  DMA1_TDeviceData* DeviceDataPtr = INT_DMA_Error__DEFAULT_RTOS_ISRPARAM;
  LDD_TEventMask ErrorMask = (LDD_TEventMask)DMA_PDD_GetErrorFlagsMask(DMA_BASE_PTR);
  uint8_t i = 0U;                      /* Auxiliary local loop iteration variable. */
  uint8_t EventFound = FALSE;          /* Auxiliary local variable ending loop. */

  while ((i < DMA1_CONFIGURED_CHANNELS_NUMBER) && (!EventFound)) {
    if ((ErrorMask & DMA1_ChannelMasks[i]) != 0x00U) {
      DeviceDataPtr->ChannelRecord[DMA1_ChannelNumbers[i]]->DescriptorPtr->OnErrorEventPtr(DeviceDataPtr->ChannelRecord[DMA1_ChannelNumbers[i]]->DescriptorPtr->UserDataPtr);
      EventFound = TRUE;
    }
    i++;
  }
  DMA_PDD_ClearErrorFlags(DMA_BASE_PTR, DMA_PDD_ALL_CHANNELS, 0U);
}
/*
** ===================================================================
**     Method      :  TransferCompleteInterrupt (component DMA_LDD)
**
**     Description :
**         Transfer complete interrupt service routine.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(DMA1_Channel0Interrupt)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  DMA1_TDeviceData* DeviceDataPtr = INT_DMA0_DMA16__DEFAULT_RTOS_ISRPARAM;
  /* Channel 0 and 16 use same interrupt vector */
  /* Interrupt from channel 0 */
  if ((DMA_PDD_GetInterruptFlagsMask(DMA_BASE_PTR) & LDD_DMA_CHANNEL_0_MASK) != 0U) {
    DeviceDataPtr->ChannelRecord[DMA1_CHANNEL_0]->DescriptorPtr->OnCompleteEventPtr(DeviceDataPtr->ChannelRecord[DMA1_CHANNEL_0]->DescriptorPtr->UserDataPtr);
    DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, DMA_PDD_ONE_CHANNEL, DMA1_CHANNEL_0);
  }
}
/* END DMA1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.08]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
